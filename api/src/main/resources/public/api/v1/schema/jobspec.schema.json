{
  "$schema": "http://json-schema.org/schema#",
  "definitions": {
    "pathType": {
      "type": "string",
      "pattern": "^([a-z0-9]([a-z0-9-]*[a-z0-9]+)*)([.][a-z0-9]([a-z0-9-]*[a-z0-9]+)*)*$",
      "minLength": 1
    }
  },
  "type": "object",
  "additionalProperties": false,
  "properties": {
    "id": {
      "$ref": "#/definitions/pathType",
      "description": "Unique identifier for the job consisting of a series of names separated by dots. Each name must be at least 1 character and may only contain digits (`0-9`), dashes (`-`), and lowercase letters (`a-z`). The name may not begin or end with a dash."

    },
    "description": {
      "type": "string",
      "description": "A description of this job."
    },
    "labels": {
      "type": "object",
      "description": "Attaching metadata to jobs can be useful to expose additional information to other services, so we added the ability to place labels on jobs (for example, you could label jobs staging and production to mark services by their position in the pipeline).",
      "additionalProperties": {
        "type": "string"
      }
    },
    "run": {
      "type": "object",
      "additionalProperties": false,
      "description": "A run specification",
      "properties": {
        "args": {
          "items": {
            "type": "string"
          },
          "type": "array",
          "description": "An array of strings that represents an alternative mode of specifying the command to run. This was motivated by safe usage of containerizer features like a custom Docker ENTRYPOINT. Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same job."
        },
        "artifacts": {
          "type": "array",
          "description": "Provided URIs are passed to Mesos fetcher module and resolved in runtime.",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "properties": {
              "uri": {
                "type": "string",
                "description": "URI to be fetched by Mesos fetcher module"
              },
              "executable": {
                "type": "boolean",
                "description": "Set fetched artifact as executable"
              },
              "extract": {
                "type": "boolean",
                "description": "Extract fetched artifact if supported by Mesos fetcher module"
              },
              "cache": {
                "type": "boolean",
                "description": "Cache fetched artifact if supported by Mesos fetcher module"
              }
            },
            "required": [ "uri" ]
          }
        },
        "cmd": {
          "description": "The command that is executed.  This value is wrapped by Mesos via `/bin/sh -c ${job.cmd}`.  Either `cmd` or `args` must be supplied. It is invalid to supply both `cmd` and `args` in the same job.",
          "type": "string",
          "minLength": 1
        },
        "cpus": {
          "type": "number",
          "description": "The number of CPU shares this job needs per instance. This number does not have to be integer, but can be a fraction.",
          "minimum": 0.01
        },
        "disk": {
          "type": "number",
          "description": "How much disk space is needed for this job. This number does not have to be an integer, but can be a fraction.",
          "minimum": 0
        },
        "docker": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "credential": {
              "type": "object",
              "description": "Credential to authenticate with the docker registry.",
              "additionalProperties": false,
              "properties": {
                "principal": {
                  "type": "string",
                  "description": "Principal to authenticate with the docker registry."
                },
                "secret": {
                  "type": "string",
                  "description": "Secret to authenticate with the docker registry."
                }
              },
              "required": [ "principal" ]
            },
            "forcePullImage": {
              "type": "boolean",
              "description": "The container will be pulled, regardless if it is already available on the local system."
            },
            "image": {
              "type": "string",
              "minLength": 1,
              "description": "The name of the docker image to use."
            },
            "network": {
              "type": "string",
              "description": "The networking mode, this container should operate in. One of BRIDGE|HOST|NONE|USER",
              "enum": ["BRIDGE", "HOST", "NONE", "USER"]
            },
            "parameters": {
              "type": "array",
              "description": "Allowing arbitrary parameters to be passed to docker CLI. Note that anything passed to this field is not guaranteed to be supported moving forward, as we might move away from the docker CLI.",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "key": {
                    "type": "string",
                    "minLength": 1,
                    "description": "Key of this parameter"
                  },
                  "value": {
                    "type": "string",
                    "description": "Value of this parameter"
                  }
                },
                "required": [ "key", "value" ]
              }
            },
            "portMappings": {
              "type": "array",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "containerPort": {
                    "type": "integer",
                    "description": "Refers to the port the application listens to inside of the container. It is optional and defaults to 0. For each containerPort with a value of 0 Marathon assigns the containerPort the same value as the assigned hostPort. This is especially useful for apps that advertise the port they are listening on to the outside world for P2P communication. Without containerPort: 0 they would erroneously advertise their private container port which is usually not the same as the externally visible host port.",
                    "maximum": 65535,
                    "minimum": 0
                  },
                  "hostPort": {
                    "type": "integer",
                    "description": "Retains the traditional meaning in Marathon, which is a random port from the range included in the Mesos resource offer. The resulting host ports for each task are exposed via the task details in the REST API and the Marathon web UI. hostPort is optional. In BRIDGE mode it defaults to 0 if left unspecified. In USER mode an unspecified hostPort does not allocate a port from a Mesos offer.",
                    "maximum": 65535,
                    "minimum": 0
                  },
                  "labels": {
                    "type": "object",
                    "description": "This can be used to add metadata to be interpreted by external applications such as firewalls.",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "name": {
                    "type": "string",
                    "description": "Name of the service hosted on this port. If provided, it must be unique over all port mappings.",
                    "pattern": "^[a-z][a-z0-9-]*$"
                  },
                  "protocol": {
                    "type": "string",
                    "enum": ["tcp", "udp", "udp,tcp"],
                    "description": "Protocol of the port (one of ['tcp', 'udp'] or 'udp,tcp' for both). Defaults to 'tcp'."
                  },
                  "servicePort": {
                    "type": "integer",
                    "description": "Is a helper port intended for doing service discovery using a well-known port per service. The assigned servicePort value is not used/interpreted by Marathon itself but supposed to used by load balancer infrastructure. See Service Discovery Load Balancing doc page. The servicePort parameter is optional and defaults to 0. Like hostPort, If the value is 0, a random port will be assigned. If a servicePort value is assigned by Marathon then Marathon guarantees that its value is unique across the cluster. The values for random service ports are in the range [local_port_min, local_port_max] where local_port_min and local_port_max are command line options with default values of 10000 and 20000, respectively.",
                    "maximum": 65535,
                    "minimum": 0
                  }
                }
              }
            },
            "privileged": {
              "type": "boolean",
              "description": "Run this docker image in privileged mode."
            }
          },
          "required": ["image"]
        },
        "env": {
          "type": "object",
          "patternProperties": {
            ".*": {
              "oneOf": [
                { "type": "string" }
              ]
            }
          }
        },
        "maxLaunchDelay": {
          "type": "integer",
          "minimum": 1,
          "description": "The number of seconds until the job needs to be running. If the deadline is reached without successfully running the job, the job is aborted."
        },
        "mem": {
          "type": "number",
          "description": "The amount of memory in MB that is needed for the job per instance.",
          "minimum": 32
        },
        "placement": {
          "type": "object",
          "additionalProperties": false,
          "properties": {
            "constraints": {
              "type": "array",
              "description": "The array of constraints to place this job.",
              "items": {
                "type": "object",
                "additionalProperties": false,
                "properties": {
                  "attribute": {
                    "type": "string",
                    "description": "The attribute name for this constraint."
                  },
                  "operator": {
                    "type": "string",
                    "description": "The operator for this constraint.",
                    "enum": ["EQ", "LIKE", "UNLIKE"]
                  },
                  "value": {
                    "type": "string",
                    "description": "The value for this constraint."
                  }
                },
                "required": ["attribute", "operator"]
              }
            }
          }
        },
        "user": {
          "type": "string",
          "description": "The user to use to run the tasks on the agent."
        },
        "restart": {
          "type": "object",
          "additionalProperties": false,
          "documentation": "Defines the behavior if a task fails",
          "properties": {
            "policy": {
              "type": "string",
              "documentation": "The policy to use if a job fails. NEVER will never try to relaunch a job. ON_FAILURE will try to start a job in case of failure.",
              "enum": ["NEVER", "ON_FAILURE"]
            },
            "activeDeadlineSeconds": {
              "type": "integer",
              "documentation": "If the job fails, how long should we try to restart the job. If no value is set, this means forever."
            }
          },
          "required": ["policy"]
        },
        "volumes": {
          "type": "array",
          "documentation": "The list of volumes for this job.",
          "items": {
            "type": "object",
            "additionalProperties": false,
            "documentation": "A volume definition for this job.",
            "properties": {
              "containerPath": {
                "type": "string",
                "description": "The path of the volume in the container",
                "minLength": 1,
                "pattern": "^/[^/].*$"
              },
              "hostPath": {
                "type": "string",
                "description": "The path of the volume on the host",
                "minLength": 1
              },
              "mode": {
                "type": "string",
                "description": "Possible values are RO for ReadOnly and RW for Read/Write",
                "enum": ["RO", "RW"]
              }
            },
            "required": ["containerPath", "hostPath", "mode"]
          }
        }
      },
      "required": ["cpus", "mem", "disk"]
    }
  },
  "required": ["id", "run"]
}
